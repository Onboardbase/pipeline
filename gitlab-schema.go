// Code generated by schema-generate. DO NOT EDIT.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// Artifacts
type Artifacts struct {
	Exclude   []string `json:"exclude,omitempty"`
	ExpireIn  string   `json:"expire_in,omitempty"`
	ExposeAs  string   `json:"expose_as,omitempty"`
	Name      string   `json:"name,omitempty"`
	Paths     []string `json:"paths,omitempty"`
	Reports   *Reports `json:"reports,omitempty"`
	Untracked bool     `json:"untracked,omitempty"`
	When      string   `json:"when,omitempty"`
}

// Assets
type Assets struct {

	// Include asset links in the release.
	Links []*LinksItems `json:"links"`
}

// Cache
type Cache struct {
	FallbackKeys []string    `json:"fallback_keys,omitempty"`
	Key          interface{} `json:"key,omitempty"`
	Paths        []string    `json:"paths,omitempty"`
	Policy       string      `json:"policy,omitempty"`
	Unprotect    bool        `json:"unprotect,omitempty"`
	Untracked    bool        `json:"untracked,omitempty"`
	When         string      `json:"when,omitempty"`
}

// CoverageReport_object Used to collect coverage reports from the job.
type CoverageReport_object struct {

	// Code coverage format used by the test framework.
	CoverageFormat interface{} `json:"coverage_format,omitempty"`

	// Path to the coverage report file that should be parsed.
	Path string `json:"path,omitempty"`
}

// Default
type Default struct {
	AfterScript   []interface{} `json:"after_script,omitempty"`
	Artifacts     *Artifacts    `json:"artifacts,omitempty"`
	BeforeScript  []interface{} `json:"before_script,omitempty"`
	Cache         *Cache        `json:"cache,omitempty"`
	Hooks         *Hooks        `json:"hooks,omitempty"`
	Image         interface{}   `json:"image,omitempty"`
	Interruptible bool          `json:"interruptible,omitempty"`
	Reference     []string      `json:"!reference,omitempty"`
	Retry         interface{}   `json:"retry,omitempty"`
	Services      []interface{} `json:"services,omitempty"`
	Tags          []interface{} `json:"tags,omitempty"`
	Timeout       string        `json:"timeout,omitempty"`
}

// GlobalVariables
type GlobalVariables struct {
}

// Hooks
type Hooks struct {
	PreGetSourcesScript interface{} `json:"pre_get_sources_script,omitempty"`
}

// IdTokens
type IdTokens struct {
}

// Inherit
type Inherit struct {
	Default   interface{} `json:"default,omitempty"`
	Variables interface{} `json:"variables,omitempty"`
}

// Inputs
type Inputs struct {
}

// JobTemplate
type JobTemplate struct {
	AfterScript  []interface{} `json:"after_script,omitempty"`
	AllowFailure interface{}   `json:"allow_failure,omitempty"`
	Artifacts    *Artifacts    `json:"artifacts,omitempty"`
	BeforeScript []interface{} `json:"before_script,omitempty"`
	Cache        *Cache        `json:"cache,omitempty"`

	// Must be a regular expression, optionally but recommended to be quoted, and must be surrounded with '/'. Example: '/Code coverage: \d+\.\d+/'
	Coverage string `json:"coverage,omitempty"`

	// Specify a list of job names from earlier stages from which artifacts should be loaded. By default, all previous artifacts are passed. Use an empty array to skip downloading artifacts.
	Dependencies []string `json:"dependencies,omitempty"`

	// Used to associate environment metadata with a deploy. Environment can have a name and URL attached to it, and will be displayed under /environments under the project.
	Environment interface{} `json:"environment,omitempty"`

	// Job will run *except* for when these filtering options match.
	Except interface{} `json:"except,omitempty"`

	// The name of one or more jobs to inherit configuration from.
	Extends       interface{} `json:"extends,omitempty"`
	Hooks         *Hooks      `json:"hooks,omitempty"`
	IdTokens      *IdTokens   `json:"id_tokens,omitempty"`
	Image         interface{} `json:"image,omitempty"`
	Inherit       *Inherit    `json:"inherit,omitempty"`
	Interruptible bool        `json:"interruptible,omitempty"`

	// The list of jobs in previous stages whose sole completion is needed to start the current job.
	Needs []interface{} `json:"needs,omitempty"`

	// Job will run *only* when these filtering options match.
	Only interface{} `json:"only,omitempty"`

	// Parallel will split up a single job into several, and provide `CI_NODE_INDEX` and `CI_NODE_TOTAL` environment variables for the running jobs.
	Parallel interface{} `json:"parallel,omitempty"`

	// A path to a directory that contains the files to be published with Pages
	Publish string `json:"publish,omitempty"`

	// Indicates that the job creates a Release.
	Release *Release `json:"release,omitempty"`

	// Limit job concurrency. Can be used to ensure that the Runner will not run certain jobs simultaneously.
	ResourceGroup string        `json:"resource_group,omitempty"`
	Retry         interface{}   `json:"retry,omitempty"`
	Rules         interface{}   `json:"rules,omitempty"`
	Script        interface{}   `json:"script,omitempty"`
	Secrets       *Secrets      `json:"secrets,omitempty"`
	Services      []interface{} `json:"services,omitempty"`

	// Define what stage the job will run in.
	Stage     interface{}   `json:"stage,omitempty"`
	StartIn   string        `json:"start_in,omitempty"`
	Tags      []interface{} `json:"tags,omitempty"`
	Timeout   string        `json:"timeout,omitempty"`
	Trigger   interface{}   `json:"trigger,omitempty"`
	Variables *JobVariables `json:"variables,omitempty"`
	When      string        `json:"when,omitempty"`
}

// JobVariables
type JobVariables struct {
}

// LinksItems
type LinksItems struct {

	// The redirect link to the url.
	Filepath string `json:"filepath,omitempty"`

	// The content kind of what users can download via url.
	LinkType string `json:"link_type,omitempty"`

	// The name of the link.
	Name string `json:"name"`

	// The URL to download a file.
	Url string `json:"url"`
}

// Release Indicates that the job creates a Release.
type Release struct {
	Assets *Assets `json:"assets,omitempty"`

	// Specifies the longer description of the Release.
	Description string `json:"description"`

	// The title of each milestone the release is associated with.
	Milestones []string `json:"milestones,omitempty"`

	// The Release name. If omitted, it is populated with the value of release: tag_name.
	Name string `json:"name,omitempty"`

	// If the release: tag_name doesnâ€™t exist yet, the release is created from ref. ref can be a commit SHA, another tag name, or a branch name.
	Ref string `json:"ref,omitempty"`

	// The date and time when the release is ready. Defaults to the current date and time if not defined. Should be enclosed in quotes and expressed in ISO 8601 format.
	ReleasedAt string `json:"released_at,omitempty"`

	// Message to use if creating a new annotated tag.
	TagMessage string `json:"tag_message,omitempty"`

	// The tag_name must be specified. It can refer to an existing Git tag or can be specified by the user.
	TagName string `json:"tag_name"`
}

// Reports
type Reports struct {

	// Path to a single file with browser performance metric report(s).
	BrowserPerformance string `json:"browser_performance,omitempty"`

	// Path to file or list of files with code quality report(s) (such as Code Climate).
	Codequality interface{} `json:"codequality,omitempty"`

	// Path to file or list of files with Container scanning vulnerabilities report(s).
	ContainerScanning interface{} `json:"container_scanning,omitempty"`

	// Used to collect coverage reports from the job.
	CoverageReport interface{} `json:"coverage_report,omitempty"`
	Cyclonedx      interface{} `json:"cyclonedx,omitempty"`

	// Path to file or list of files with DAST vulnerabilities report(s).
	Dast interface{} `json:"dast,omitempty"`

	// Path to file or list of files with Dependency scanning vulnerabilities report(s).
	DependencyScanning interface{} `json:"dependency_scanning,omitempty"`

	// Path to file or list of files containing runtime-created variables for this job.
	Dotenv interface{} `json:"dotenv,omitempty"`

	// Path for file(s) that should be parsed as JUnit XML result
	Junit interface{} `json:"junit,omitempty"`

	// Deprecated in 12.8: Path to file or list of files with license report(s).
	LicenseManagement interface{} `json:"license_management,omitempty"`

	// Path to file or list of files with license report(s).
	LicenseScanning interface{} `json:"license_scanning,omitempty"`
	LoadPerformance interface{} `json:"load_performance,omitempty"`

	// Path to file or list of files containing code intelligence (Language Server Index Format).
	Lsif interface{} `json:"lsif,omitempty"`

	// Path to file or list of files with custom metrics report(s).
	Metrics interface{} `json:"metrics,omitempty"`

	// Path to file or list of files with requirements report(s).
	Requirements interface{} `json:"requirements,omitempty"`

	// Path to file or list of files with SAST vulnerabilities report(s).
	Sast interface{} `json:"sast,omitempty"`

	// Path to file or list of files with secret detection report(s).
	SecretDetection interface{} `json:"secret_detection,omitempty"`

	// Path to file or list of files with terraform plan(s).
	Terraform interface{} `json:"terraform,omitempty"`
}

// Root
type Root struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	AfterScript          []interface{}          `json:"after_script,omitempty"`
	BeforeScript         []interface{}          `json:"before_script,omitempty"`
	Cache                *Cache                 `json:"cache,omitempty"`
	Default              *Default               `json:"default,omitempty"`
	Image                interface{}            `json:"image,omitempty"`
	Include              interface{}            `json:"include,omitempty"`
	Pages                interface{}            `json:"pages,omitempty"`
	Reference            []string               `json:"!reference,omitempty"`
	Schema               string                 `json:"$schema,omitempty"`
	Services             []interface{}          `json:"services,omitempty"`
	Stages               []string               `json:"stages,omitempty"`
	Variables            *GlobalVariables       `json:"variables,omitempty"`
	Workflow             *Workflow              `json:"workflow,omitempty"`
}

// RulesItems
type RulesItems struct {
	Changes   interface{}     `json:"changes,omitempty"`
	Exists    []string        `json:"exists,omitempty"`
	If        string          `json:"if,omitempty"`
	Variables *RulesVariables `json:"variables,omitempty"`
	When      string          `json:"when,omitempty"`
}

// RulesVariables
type RulesVariables struct {
}

// Secrets
type Secrets struct {
}

// Workflow
type Workflow struct {
	Name  string        `json:"name,omitempty"`
	Rules []*RulesItems `json:"rules,omitempty"`
}

func (strct *Artifacts) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "exclude" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"exclude\": ")
	if tmp, err := json.Marshal(strct.Exclude); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "expire_in" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"expire_in\": ")
	if tmp, err := json.Marshal(strct.ExpireIn); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "expose_as" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"expose_as\": ")
	if tmp, err := json.Marshal(strct.ExposeAs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "paths" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "reports" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"reports\": ")
	if tmp, err := json.Marshal(strct.Reports); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "untracked" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"untracked\": ")
	if tmp, err := json.Marshal(strct.Untracked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "when" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Artifacts) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "exclude":
			if err := json.Unmarshal([]byte(v), &strct.Exclude); err != nil {
				return err
			}
		case "expire_in":
			if err := json.Unmarshal([]byte(v), &strct.ExpireIn); err != nil {
				return err
			}
		case "expose_as":
			if err := json.Unmarshal([]byte(v), &strct.ExposeAs); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "paths":
			if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
				return err
			}
		case "reports":
			if err := json.Unmarshal([]byte(v), &strct.Reports); err != nil {
				return err
			}
		case "untracked":
			if err := json.Unmarshal([]byte(v), &strct.Untracked); err != nil {
				return err
			}
		case "when":
			if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *Assets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Links" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "links" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Assets) UnmarshalJSON(b []byte) error {
	linksReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "links":
			if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
				return err
			}
			linksReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if links (a required property) was received
	if !linksReceived {
		return errors.New("\"links\" is required but was not present")
	}
	return nil
}

func (strct *Default) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "after_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"after_script\": ")
	if tmp, err := json.Marshal(strct.AfterScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "artifacts" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"artifacts\": ")
	if tmp, err := json.Marshal(strct.Artifacts); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "before_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"before_script\": ")
	if tmp, err := json.Marshal(strct.BeforeScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cache" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cache\": ")
	if tmp, err := json.Marshal(strct.Cache); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hooks" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hooks\": ")
	if tmp, err := json.Marshal(strct.Hooks); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "image" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "interruptible" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"interruptible\": ")
	if tmp, err := json.Marshal(strct.Interruptible); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "!reference" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"!reference\": ")
	if tmp, err := json.Marshal(strct.Reference); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "retry" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"retry\": ")
	if tmp, err := json.Marshal(strct.Retry); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "services" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"services\": ")
	if tmp, err := json.Marshal(strct.Services); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "timeout" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timeout\": ")
	if tmp, err := json.Marshal(strct.Timeout); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Default) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "after_script":
			if err := json.Unmarshal([]byte(v), &strct.AfterScript); err != nil {
				return err
			}
		case "artifacts":
			if err := json.Unmarshal([]byte(v), &strct.Artifacts); err != nil {
				return err
			}
		case "before_script":
			if err := json.Unmarshal([]byte(v), &strct.BeforeScript); err != nil {
				return err
			}
		case "cache":
			if err := json.Unmarshal([]byte(v), &strct.Cache); err != nil {
				return err
			}
		case "hooks":
			if err := json.Unmarshal([]byte(v), &strct.Hooks); err != nil {
				return err
			}
		case "image":
			if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
				return err
			}
		case "interruptible":
			if err := json.Unmarshal([]byte(v), &strct.Interruptible); err != nil {
				return err
			}
		case "!reference":
			if err := json.Unmarshal([]byte(v), &strct.Reference); err != nil {
				return err
			}
		case "retry":
			if err := json.Unmarshal([]byte(v), &strct.Retry); err != nil {
				return err
			}
		case "services":
			if err := json.Unmarshal([]byte(v), &strct.Services); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		case "timeout":
			if err := json.Unmarshal([]byte(v), &strct.Timeout); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *Hooks) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "pre_get_sources_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"pre_get_sources_script\": ")
	if tmp, err := json.Marshal(strct.PreGetSourcesScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Hooks) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "pre_get_sources_script":
			if err := json.Unmarshal([]byte(v), &strct.PreGetSourcesScript); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *Inherit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "default" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "variables" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Inherit) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "default":
			if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
				return err
			}
		case "variables":
			if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *JobTemplate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "after_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"after_script\": ")
	if tmp, err := json.Marshal(strct.AfterScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "allow_failure" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"allow_failure\": ")
	if tmp, err := json.Marshal(strct.AllowFailure); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "artifacts" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"artifacts\": ")
	if tmp, err := json.Marshal(strct.Artifacts); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "before_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"before_script\": ")
	if tmp, err := json.Marshal(strct.BeforeScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cache" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cache\": ")
	if tmp, err := json.Marshal(strct.Cache); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "coverage" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"coverage\": ")
	if tmp, err := json.Marshal(strct.Coverage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dependencies" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dependencies\": ")
	if tmp, err := json.Marshal(strct.Dependencies); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "environment" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"environment\": ")
	if tmp, err := json.Marshal(strct.Environment); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "except" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"except\": ")
	if tmp, err := json.Marshal(strct.Except); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extends" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extends\": ")
	if tmp, err := json.Marshal(strct.Extends); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "hooks" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hooks\": ")
	if tmp, err := json.Marshal(strct.Hooks); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "id_tokens" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"id_tokens\": ")
	if tmp, err := json.Marshal(strct.IdTokens); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "image" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "inherit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"inherit\": ")
	if tmp, err := json.Marshal(strct.Inherit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "interruptible" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"interruptible\": ")
	if tmp, err := json.Marshal(strct.Interruptible); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "needs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"needs\": ")
	if tmp, err := json.Marshal(strct.Needs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "only" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"only\": ")
	if tmp, err := json.Marshal(strct.Only); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "parallel" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"parallel\": ")
	if tmp, err := json.Marshal(strct.Parallel); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "publish" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"publish\": ")
	if tmp, err := json.Marshal(strct.Publish); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "release" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"release\": ")
	if tmp, err := json.Marshal(strct.Release); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "resource_group" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"resource_group\": ")
	if tmp, err := json.Marshal(strct.ResourceGroup); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "retry" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"retry\": ")
	if tmp, err := json.Marshal(strct.Retry); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "rules" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"rules\": ")
	if tmp, err := json.Marshal(strct.Rules); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"script\": ")
	if tmp, err := json.Marshal(strct.Script); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "secrets" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"secrets\": ")
	if tmp, err := json.Marshal(strct.Secrets); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "services" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"services\": ")
	if tmp, err := json.Marshal(strct.Services); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "stage" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"stage\": ")
	if tmp, err := json.Marshal(strct.Stage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "start_in" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"start_in\": ")
	if tmp, err := json.Marshal(strct.StartIn); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "timeout" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timeout\": ")
	if tmp, err := json.Marshal(strct.Timeout); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "trigger" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"trigger\": ")
	if tmp, err := json.Marshal(strct.Trigger); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "variables" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "when" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JobTemplate) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "after_script":
			if err := json.Unmarshal([]byte(v), &strct.AfterScript); err != nil {
				return err
			}
		case "allow_failure":
			if err := json.Unmarshal([]byte(v), &strct.AllowFailure); err != nil {
				return err
			}
		case "artifacts":
			if err := json.Unmarshal([]byte(v), &strct.Artifacts); err != nil {
				return err
			}
		case "before_script":
			if err := json.Unmarshal([]byte(v), &strct.BeforeScript); err != nil {
				return err
			}
		case "cache":
			if err := json.Unmarshal([]byte(v), &strct.Cache); err != nil {
				return err
			}
		case "coverage":
			if err := json.Unmarshal([]byte(v), &strct.Coverage); err != nil {
				return err
			}
		case "dependencies":
			if err := json.Unmarshal([]byte(v), &strct.Dependencies); err != nil {
				return err
			}
		case "environment":
			if err := json.Unmarshal([]byte(v), &strct.Environment); err != nil {
				return err
			}
		case "except":
			if err := json.Unmarshal([]byte(v), &strct.Except); err != nil {
				return err
			}
		case "extends":
			if err := json.Unmarshal([]byte(v), &strct.Extends); err != nil {
				return err
			}
		case "hooks":
			if err := json.Unmarshal([]byte(v), &strct.Hooks); err != nil {
				return err
			}
		case "id_tokens":
			if err := json.Unmarshal([]byte(v), &strct.IdTokens); err != nil {
				return err
			}
		case "image":
			if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
				return err
			}
		case "inherit":
			if err := json.Unmarshal([]byte(v), &strct.Inherit); err != nil {
				return err
			}
		case "interruptible":
			if err := json.Unmarshal([]byte(v), &strct.Interruptible); err != nil {
				return err
			}
		case "needs":
			if err := json.Unmarshal([]byte(v), &strct.Needs); err != nil {
				return err
			}
		case "only":
			if err := json.Unmarshal([]byte(v), &strct.Only); err != nil {
				return err
			}
		case "parallel":
			if err := json.Unmarshal([]byte(v), &strct.Parallel); err != nil {
				return err
			}
		case "publish":
			if err := json.Unmarshal([]byte(v), &strct.Publish); err != nil {
				return err
			}
		case "release":
			if err := json.Unmarshal([]byte(v), &strct.Release); err != nil {
				return err
			}
		case "resource_group":
			if err := json.Unmarshal([]byte(v), &strct.ResourceGroup); err != nil {
				return err
			}
		case "retry":
			if err := json.Unmarshal([]byte(v), &strct.Retry); err != nil {
				return err
			}
		case "rules":
			if err := json.Unmarshal([]byte(v), &strct.Rules); err != nil {
				return err
			}
		case "script":
			if err := json.Unmarshal([]byte(v), &strct.Script); err != nil {
				return err
			}
		case "secrets":
			if err := json.Unmarshal([]byte(v), &strct.Secrets); err != nil {
				return err
			}
		case "services":
			if err := json.Unmarshal([]byte(v), &strct.Services); err != nil {
				return err
			}
		case "stage":
			if err := json.Unmarshal([]byte(v), &strct.Stage); err != nil {
				return err
			}
		case "start_in":
			if err := json.Unmarshal([]byte(v), &strct.StartIn); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		case "timeout":
			if err := json.Unmarshal([]byte(v), &strct.Timeout); err != nil {
				return err
			}
		case "trigger":
			if err := json.Unmarshal([]byte(v), &strct.Trigger); err != nil {
				return err
			}
		case "variables":
			if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
			}
		case "when":
			if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *LinksItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "filepath" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"filepath\": ")
	if tmp, err := json.Marshal(strct.Filepath); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "link_type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"link_type\": ")
	if tmp, err := json.Marshal(strct.LinkType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LinksItems) UnmarshalJSON(b []byte) error {
	nameReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "filepath":
			if err := json.Unmarshal([]byte(v), &strct.Filepath); err != nil {
				return err
			}
		case "link_type":
			if err := json.Unmarshal([]byte(v), &strct.LinkType); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Release) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "assets" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"assets\": ")
	if tmp, err := json.Marshal(strct.Assets); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Description" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "milestones" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"milestones\": ")
	if tmp, err := json.Marshal(strct.Milestones); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "ref" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "released_at" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"released_at\": ")
	if tmp, err := json.Marshal(strct.ReleasedAt); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tag_message" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tag_message\": ")
	if tmp, err := json.Marshal(strct.TagMessage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "TagName" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "tag_name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tag_name\": ")
	if tmp, err := json.Marshal(strct.TagName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Release) UnmarshalJSON(b []byte) error {
	descriptionReceived := false
	tag_nameReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "assets":
			if err := json.Unmarshal([]byte(v), &strct.Assets); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
			descriptionReceived = true
		case "milestones":
			if err := json.Unmarshal([]byte(v), &strct.Milestones); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "ref":
			if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
				return err
			}
		case "released_at":
			if err := json.Unmarshal([]byte(v), &strct.ReleasedAt); err != nil {
				return err
			}
		case "tag_message":
			if err := json.Unmarshal([]byte(v), &strct.TagMessage); err != nil {
				return err
			}
		case "tag_name":
			if err := json.Unmarshal([]byte(v), &strct.TagName); err != nil {
				return err
			}
			tag_nameReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if description (a required property) was received
	if !descriptionReceived {
		return errors.New("\"description\" is required but was not present")
	}
	// check if tag_name (a required property) was received
	if !tag_nameReceived {
		return errors.New("\"tag_name\" is required but was not present")
	}
	return nil
}

func (strct *Reports) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "browser_performance" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"browser_performance\": ")
	if tmp, err := json.Marshal(strct.BrowserPerformance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "codequality" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"codequality\": ")
	if tmp, err := json.Marshal(strct.Codequality); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "container_scanning" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"container_scanning\": ")
	if tmp, err := json.Marshal(strct.ContainerScanning); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "coverage_report" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"coverage_report\": ")
	if tmp, err := json.Marshal(strct.CoverageReport); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cyclonedx" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cyclonedx\": ")
	if tmp, err := json.Marshal(strct.Cyclonedx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dast" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dast\": ")
	if tmp, err := json.Marshal(strct.Dast); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dependency_scanning" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dependency_scanning\": ")
	if tmp, err := json.Marshal(strct.DependencyScanning); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dotenv" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dotenv\": ")
	if tmp, err := json.Marshal(strct.Dotenv); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "junit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"junit\": ")
	if tmp, err := json.Marshal(strct.Junit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "license_management" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"license_management\": ")
	if tmp, err := json.Marshal(strct.LicenseManagement); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "license_scanning" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"license_scanning\": ")
	if tmp, err := json.Marshal(strct.LicenseScanning); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "load_performance" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"load_performance\": ")
	if tmp, err := json.Marshal(strct.LoadPerformance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "lsif" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lsif\": ")
	if tmp, err := json.Marshal(strct.Lsif); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "metrics" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"metrics\": ")
	if tmp, err := json.Marshal(strct.Metrics); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "requirements" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"requirements\": ")
	if tmp, err := json.Marshal(strct.Requirements); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sast" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sast\": ")
	if tmp, err := json.Marshal(strct.Sast); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "secret_detection" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"secret_detection\": ")
	if tmp, err := json.Marshal(strct.SecretDetection); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "terraform" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"terraform\": ")
	if tmp, err := json.Marshal(strct.Terraform); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Reports) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "browser_performance":
			if err := json.Unmarshal([]byte(v), &strct.BrowserPerformance); err != nil {
				return err
			}
		case "codequality":
			if err := json.Unmarshal([]byte(v), &strct.Codequality); err != nil {
				return err
			}
		case "container_scanning":
			if err := json.Unmarshal([]byte(v), &strct.ContainerScanning); err != nil {
				return err
			}
		case "coverage_report":
			if err := json.Unmarshal([]byte(v), &strct.CoverageReport); err != nil {
				return err
			}
		case "cyclonedx":
			if err := json.Unmarshal([]byte(v), &strct.Cyclonedx); err != nil {
				return err
			}
		case "dast":
			if err := json.Unmarshal([]byte(v), &strct.Dast); err != nil {
				return err
			}
		case "dependency_scanning":
			if err := json.Unmarshal([]byte(v), &strct.DependencyScanning); err != nil {
				return err
			}
		case "dotenv":
			if err := json.Unmarshal([]byte(v), &strct.Dotenv); err != nil {
				return err
			}
		case "junit":
			if err := json.Unmarshal([]byte(v), &strct.Junit); err != nil {
				return err
			}
		case "license_management":
			if err := json.Unmarshal([]byte(v), &strct.LicenseManagement); err != nil {
				return err
			}
		case "license_scanning":
			if err := json.Unmarshal([]byte(v), &strct.LicenseScanning); err != nil {
				return err
			}
		case "load_performance":
			if err := json.Unmarshal([]byte(v), &strct.LoadPerformance); err != nil {
				return err
			}
		case "lsif":
			if err := json.Unmarshal([]byte(v), &strct.Lsif); err != nil {
				return err
			}
		case "metrics":
			if err := json.Unmarshal([]byte(v), &strct.Metrics); err != nil {
				return err
			}
		case "requirements":
			if err := json.Unmarshal([]byte(v), &strct.Requirements); err != nil {
				return err
			}
		case "sast":
			if err := json.Unmarshal([]byte(v), &strct.Sast); err != nil {
				return err
			}
		case "secret_detection":
			if err := json.Unmarshal([]byte(v), &strct.SecretDetection); err != nil {
				return err
			}
		case "terraform":
			if err := json.Unmarshal([]byte(v), &strct.Terraform); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "after_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"after_script\": ")
	if tmp, err := json.Marshal(strct.AfterScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "before_script" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"before_script\": ")
	if tmp, err := json.Marshal(strct.BeforeScript); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cache" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cache\": ")
	if tmp, err := json.Marshal(strct.Cache); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "default" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "image" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "include" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"include\": ")
	if tmp, err := json.Marshal(strct.Include); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "pages" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"pages\": ")
	if tmp, err := json.Marshal(strct.Pages); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "!reference" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"!reference\": ")
	if tmp, err := json.Marshal(strct.Reference); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "$schema" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"$schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "services" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"services\": ")
	if tmp, err := json.Marshal(strct.Services); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "stages" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"stages\": ")
	if tmp, err := json.Marshal(strct.Stages); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "variables" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "workflow" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"workflow\": ")
	if tmp, err := json.Marshal(strct.Workflow); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "after_script":
			if err := json.Unmarshal([]byte(v), &strct.AfterScript); err != nil {
				return err
			}
		case "before_script":
			if err := json.Unmarshal([]byte(v), &strct.BeforeScript); err != nil {
				return err
			}
		case "cache":
			if err := json.Unmarshal([]byte(v), &strct.Cache); err != nil {
				return err
			}
		case "default":
			if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
				return err
			}
		case "image":
			if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
				return err
			}
		case "include":
			if err := json.Unmarshal([]byte(v), &strct.Include); err != nil {
				return err
			}
		case "pages":
			if err := json.Unmarshal([]byte(v), &strct.Pages); err != nil {
				return err
			}
		case "!reference":
			if err := json.Unmarshal([]byte(v), &strct.Reference); err != nil {
				return err
			}
		case "$schema":
			if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
				return err
			}
		case "services":
			if err := json.Unmarshal([]byte(v), &strct.Services); err != nil {
				return err
			}
		case "stages":
			if err := json.Unmarshal([]byte(v), &strct.Stages); err != nil {
				return err
			}
		case "variables":
			if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
			}
		case "workflow":
			if err := json.Unmarshal([]byte(v), &strct.Workflow); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *RulesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "changes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"changes\": ")
	if tmp, err := json.Marshal(strct.Changes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "exists" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"exists\": ")
	if tmp, err := json.Marshal(strct.Exists); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "if" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"if\": ")
	if tmp, err := json.Marshal(strct.If); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "variables" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "when" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"when\": ")
	if tmp, err := json.Marshal(strct.When); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RulesItems) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "changes":
			if err := json.Unmarshal([]byte(v), &strct.Changes); err != nil {
				return err
			}
		case "exists":
			if err := json.Unmarshal([]byte(v), &strct.Exists); err != nil {
				return err
			}
		case "if":
			if err := json.Unmarshal([]byte(v), &strct.If); err != nil {
				return err
			}
		case "variables":
			if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
			}
		case "when":
			if err := json.Unmarshal([]byte(v), &strct.When); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}
